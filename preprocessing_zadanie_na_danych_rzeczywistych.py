# -*- coding: utf-8 -*-
"""Preprocessing - zadanie na danych rzeczywistych.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1okoWmvMedJjrvBobadrV5Pc4pIHMQgwh

Rzeczywiste dane finansowe zawierają informację o cenie intrumentu oraz wartościach wskaźników technicznych. Decyzja o zakupie (BUY lub STRONGBUY), sprzedaży (SELL lub STRONGSELL), lub czekaniu (WAIT) podejmowana jest w oparciu o poniższe wskaźniki, a także na podstawie relacji pomiędzy wskaźnikami, a ceną.
1. Wczytaj dane do formatu DataFrame wybierając tylko 2500 obiektów z pliku;
2. Usuń kolumny oznaczone jako SMA14IND oraz SMA50IND;
3. Dla kolumny Close policz liczbę wystąpień danych pustych. Napraw dane w taki sposób, że pusta wartość zastępowana jest wartością uśrednioną dwóch sąsiednich elementów;
4. W przypadku danych pustych w kolumnach SMA14 i SMA50 – napraw wartości puste dowolną metodą;
5. Dla wszystkich pozostałych atrybutów wypełnij wartości puste zerami;
6. Wyznacz korelację pomiędzy SMA14 i SMA50;
7. Wyznacz korelację pomiędzy Close oraz SMA14 a także pomiędzy Close oraz SMA50. Usuń kolumnę, dla której wartość korelacji była większa;
8. Podaj liczbę elementów ujemnych dla atrybutu CCI;
9. Podaj informację o wartości maksymalnej i minialnej dla każdego atrybutu;
10. Przeprowadź normalizację dwóch wybranych atrybutów;
11. Przeprowadź dyskretyzację dwóch wybranych atrybutów (podział odpowiednio na 2 i 4 kategorie);
12. Na wykresie kołowym przedstaw rozkład wartości decyzji (atrybut Decision);
13. Na wykresie liniowym przedstaw przebieg zmienności atrybutu Close;
14. Dane po preprocessingu zapisz do pliku w formacie JSON.
"""

import pandas

#wczytanie pliku
dane = pandas.read_csv("/content/EURUSD_H4.csv")

dane2500 = dane.head(2500)  #wybrane górne 2500 obektów

#Usuń kolumny oznaczone jako SMA14IND oraz SMA50IND
nowe_dane = dane2500.drop(['SMA14IND', 'SMA50IND'], axis = 1)   #axis = 1 czyli usuwam kolumnę (0 to byłby wiersz), jeśli nie chciałabym tworzyć nowej zmiennej to trzeba by dopisać inplace = True

#Dla kolumny Close policz liczbę wystąpień danych pustych. 
l_puste_close = dane2500['Close'].isna().sum()
print("Liczba wystąpień danych pustych w kolumnie Close: ",l_puste_close)

#Napraw dane w taki sposób, że pusta wartość zastępowana jest wartością
#uśrednioną dwóch sąsiednich elementów;
nowe_dane['Close'] = nowe_dane['Close'].interpolate()

#W przypadku danych pustych w kolumnach SMA14 i SMA50 – napraw wartości puste dowolną metodą;
nowe_dane['SMA14'] = nowe_dane['SMA14'].interpolate()   #naprawiłam tą samą co wyżej przez interpolate
nowe_dane['SMA50'] = nowe_dane['SMA50'].interpolate()

#Dla wszystkich pozostałych atrybutów wypełnij wartości puste zerami;
nowe_dane = nowe_dane.fillna(0)   #resztę pustych (NaN) wypełni zerami

#Wyznacz korelację pomiędzy SMA14 i SMA50
korelacjaSMA14_SMA50 = nowe_dane['SMA14'].corr(nowe_dane['SMA50'])
print("korelacja pomiędzy SMA14 i SMA50: ",korelacjaSMA14_SMA50)

#Wyznacz korelację pomiędzy Close oraz SMA14 a także pomiędzy Close oraz SMA50. 
#Usuń kolumnę, dla której wartość korelacji była większa

korelacjaClose_SMA14 = nowe_dane['Close'].corr(nowe_dane['SMA14'])
korelacjaClose_SMA50 = nowe_dane['Close'].corr(nowe_dane['SMA50'])
if korelacjaClose_SMA14 > korelacjaClose_SMA50:     
    nowe_dane = nowe_dane.drop(['SMA14'], axis = 1) 
else:                                               
    nowe_dane = nowe_dane.drop(['SMA14'], axis = 1) 

#Podaj liczbę elementów ujemnych dla atrybutu CCI;
l_el_ujemnych_CCI = (nowe_dane['CCI']).lt(0).sum()
print("liczbę elementów ujemnych dla atrybutu CCI:",l_el_ujemnych_CCI)

#Podaj informację o wartości maksymalnej i minimalnej dla każdego atrybutu
max = nowe_dane.max()             
print("wartości maksymalne:")
print(max)
min = nowe_dane.min()
print("wartości minimalne")
print(min)

#Przeprowadź normalizację dwóch wybranych atrybutów
wybrane_atrybuty = ['Bulls','CCI']
for atrybut in wybrane_atrybuty:
    max = nowe_dane[atrybut].max()   
    min = nowe_dane[atrybut].min()
    nowe_dane[atrybut] = (nowe_dane[atrybut] - min) / (max - min)   

#Przeprowadź dyskretyzację dwóch wybranych atrybutów (podział odpowiednio na 2 i 4 kategorie)
etykiety = ['0:0.5','0.5:1']
seriaBulls = nowe_dane['Bulls'] 
wynik_Bulls_dyskr = pandas.cut(seriaBulls,2,labels=etykiety) 
etykiety = ['0:0.25','0.25:0.5','0.5:0.75','0.75:1']    
seriaCCI = nowe_dane['CCI'] 
wynik_CCI_dyskr = pandas.cut(seriaCCI,4,labels=etykiety) 

#Na wykresie kołowym przedstaw rozkład wartości decyzji (atrybut Decision)
nowe_dane['Decision'].value_counts().plot.pie() #value_counst() zlicza ilość wystąpień danych w kolumnie Decision, plot.pie() jest dla wyświetlania wykresu kołowego

#Na wykresie liniowym przedstaw przebieg zmienności atrybutu Close
nowe_dane['Close'].plot()   #wyświetla mi wykres liniowy dla kolumny Close

#Dane po preprocessingu zapisz do pliku w formacie JSON.
nowe_dane.to_json("/content/drive/MyDrive/Projekt z preprocessingu/Zad1Preprocessing.json")